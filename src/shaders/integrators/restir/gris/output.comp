#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_KHR_shader_subgroup_arithmetic : enable

#include "../../../utils.glsl"

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
layout(binding = 0, rgba32f) uniform image2D image;
layout(binding = 1) buffer SceneDesc_ { SceneDesc scene_desc; };
layout(push_constant) uniform _PushConstantRay { PCReSTIRPT pc_ray; };
layout(buffer_reference, scalar) buffer GrisReservoir { ReSTIRPTReservoir d[]; };
layout(buffer_reference, scalar) buffer GrisGBuffer { ReSTIRPTGBuffer d[]; };
layout(buffer_reference, scalar) buffer GrisDirectLighting { vec3 d[]; };
GrisReservoir reservoirs = GrisReservoir(scene_desc.gris_reservoir_addr);
GrisDirectLighting direct_lighting_buffer = GrisDirectLighting(scene_desc.gris_direct_lighting_addr);
void main() {
	ivec2 coords = ivec2(gl_GlobalInvocationID.x / pc_ray.size_y, gl_GlobalInvocationID.x % pc_ray.size_y);
	if (gl_GlobalInvocationID.x >= pc_ray.size_x * pc_ray.size_y) {
		return;
	}
	const uint pingpong = (pc_ray.total_frame_num % 2);
	vec3 col = vec3(0);
	const ReSTIRPTReservoir r = reservoirs.d[gl_GlobalInvocationID.x];
	col += direct_lighting_buffer.d[gl_GlobalInvocationID.x];
	if (r.W > 0) {
		col += r.gris_data.F;
	}

	if (pc_ray.enable_accumulation == 0 || pc_ray.frame_num == 0) {
		imageStore(image, ivec2(coords), vec4(col, 1.f));
	} else {
		float w = 1. / float(pc_ray.frame_num + 1);
		vec3 old_col = imageLoad(image, ivec2(coords)).xyz;
		imageStore(image, ivec2(coords), vec4(mix(old_col, col, w), 1.f));
	}
}