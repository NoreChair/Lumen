#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require

#include "gris_commons.glsl"
GrisReservoir reservoirs = GrisReservoir(scene_desc.gris_reservoir_addr);
GrisGBuffer g_buffers = GrisGBuffer(scene_desc.gris_gbuffer_addr);

ivec2 get_neighbor_offset(inout uvec4 seed) {
	const float randa = rand(seed) * 2 * PI;
	const float randr = sqrt(rand(seed)) * pc_ray.spatial_radius;
	return ivec2(floor(cos(randa) * randr), floor(sin(randa) * randr));
}

vec3 uniform_sample_light_with_visibility_override(inout uvec4 seed, const Material mat, vec3 pos, const bool side,
												   const vec3 n_s, const vec3 wo, bool visible_light) {
	vec3 res = vec3(0);
	// Sample light
	vec3 wi;
	float wi_len;
	float pdf_light_w;
	float pdf_light_a;
	LightRecord record;
	float cos_from_light;
	const vec3 Le =
		sample_light_Li(seed, pos, pc_ray.num_lights, pdf_light_w, wi, wi_len, pdf_light_a, cos_from_light, record);
	const vec3 p = offset_ray2(pos, n_s);
	float bsdf_pdf;
	float cos_x = dot(n_s, wi);
	vec3 f = eval_bsdf(n_s, wo, mat, 1, side, wi, bsdf_pdf, cos_x);
	if (visible_light && pdf_light_w > 0) {
		const float mis_weight = is_light_delta(record.flags) ? 1 : 1 / (1 + bsdf_pdf / pdf_light_w);
		res += mis_weight * f * abs(cos_x) * Le / pdf_light_w;
	}
	if (get_light_type(record.flags) == LIGHT_AREA) {
		// Sample BSDF
		f = sample_bsdf(n_s, wo, mat, 1, side, wi, bsdf_pdf, cos_x, seed);
		if (bsdf_pdf != 0) {
			traceRayEXT(tlas, flags, 0xFF, 0, 0, 0, p, tmin, wi, tmax, 0);
			if (payload.material_idx == record.material_idx && payload.triangle_idx == record.triangle_idx) {
				const float wi_len = length(payload.pos - pos);
				const float g = abs(dot(payload.n_s, -wi)) / (wi_len * wi_len);
				const float mis_weight = 1. / (1 + pdf_light_a / (g * bsdf_pdf));
				res += f * mis_weight * abs(cos_x) * Le / bsdf_pdf;
			}
		}
	}
	return res;
}

bool connect_vertex(in GBuffer gbuffer, in GrisData data, float g_prev, vec3 direction, uvec4 reservoir_seed,
					out vec3 prefix_contribution, out vec3 L_direct, out vec3 partial_throughput, out vec3 rc_wo,
					out uint prefix_length, out float jacobian, out bool visibility) {
	if (data.rc_mat_id == -1) {
		return false;
	}

	Material hit_mat = load_material(gbuffer.material_idx, gbuffer.uv);
	vec3 pos = gbuffer.pos;
	vec3 prefix_throughput = vec3(1);

	prefix_contribution = vec3(0);
	L_direct = vec3(0);

	uint prefix_depth = 0;
	vec3 n_s = gbuffer.n_s;
	bool side = true;
	vec3 n_g = gbuffer.n_g;
	vec3 wo = -direction;
	bool specular = false;

	if (dot(n_g, wo) < 0.) n_g = -n_g;
	if (dot(n_g, n_s) < 0) {
		n_s = -n_s;
		side = false;
	}
	vec3 origin = offset_ray(gbuffer.pos, n_g);
	while (true) {
		if ((prefix_depth + data.postfix_length) >= pc_ray.max_depth - 1) {
			return false;
		}

		vec3 wi = data.rc_pos - pos;
		float wi_len = length(wi);
		wi /= wi_len;

		if (prefix_depth > 0 && (hit_mat.bsdf_props & BSDF_SPECULAR) == 0) {
			const float light_pick_pdf = 1. / pc_ray.light_triangle_count;
			vec3 contrib = prefix_throughput *
						   uniform_sample_light(reservoir_seed, hit_mat, payload.pos, side, n_s, wo) / light_pick_pdf;
			prefix_contribution += contrib;
		}

		bool connectable = is_rough(hit_mat) && wi_len > pc_ray.min_vertex_distance_ratio * pc_ray.scene_extent;
		connectable = connectable && prefix_depth >= (data.prefix_length - 1);
		bool connected = false;
		if (connectable) {
			vec3 p = offset_ray2(pos, n_s);
			any_hit_payload.hit = 1;
			traceRayEXT(tlas, gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT, 0xFF, 1, 0, 1, p,
						0, wi, wi_len - EPS, 1);
			connected = any_hit_payload.hit == 0;
			visibility = connected;
		}

		if (connected) {
			rc_wo = -wi;
			float rc_pdf;
			float cos_x = dot(n_s, wi);
			vec3 rc_f = eval_bsdf(n_s, wo, hit_mat, 1, side, wi, rc_pdf, cos_x);
			if (rc_pdf == 0) {
				return false;
			}
			// Compute the partial F
			partial_throughput = prefix_throughput * rc_f * abs(cos_x);
			// Compute the Jacobian
			float g_curr = abs(dot(data.rc_ns, rc_wo)) / (wi_len * wi_len);
			float j = g_prev == 0.0 ? 0.0 : g_curr / g_prev;
			jacobian = j;
			// Compute the direct lighting on the reconnection vertex
			const Material rc_mat = load_material(data.rc_mat_id, data.rc_uv);
			if (is_diffuse(rc_mat)) {
				L_direct = data.rc_Li;
			} else {
				const float light_pick_pdf = 1. / pc_ray.light_triangle_count;
				L_direct +=
					uniform_sample_light_with_visibility_override(data.rc_seed, rc_mat, data.rc_pos, data.rc_side == 1,
																  data.rc_ns, -wi, data.rc_nee_visible == 1) /
					light_pick_pdf;
			}
			prefix_length = prefix_depth + 1;
			return true;
		}

		float pdf, cos_theta;
		const vec3 f =
			sample_bsdf(n_s, wo, hit_mat, 1 /*radiance=cam*/, side, direction, pdf, cos_theta, reservoir_seed);
		if (pdf == 0) {
			return false;
		}

		prefix_throughput *= f * abs(cos_theta) / pdf;
		specular = (hit_mat.bsdf_props & BSDF_SPECULAR) != 0;

		traceRayEXT(tlas, flags, 0xFF, 0, 0, 0, origin, tmin, direction, tmax, 0);
		const bool found_isect = payload.material_idx != -1;

		if (!found_isect) {
			return false;
		}
		hit_mat = load_material(payload.material_idx, payload.uv);

		if (specular) {
			prefix_contribution += prefix_throughput * hit_mat.emissive_factor;
		}

		wo = -direction;
		n_s = payload.n_s;
		side = true;
		n_g = payload.n_g;
		if (dot(payload.n_g, wo) < 0.) n_g = -n_g;
		if (dot(n_g, payload.n_s) < 0) {
			n_s = -n_s;
			side = false;
		}

		origin = offset_ray(payload.pos, n_g);
		pos = payload.pos;

		prefix_depth++;
	}

	return false;
}

void main() {
	const vec2 pixel = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 in_uv = pixel / vec2(gl_LaunchSizeEXT.xy);
	vec2 d = in_uv * 2.0 - 1.0;
	vec3 primary_direction = vec3(sample_camera(d));
	GBuffer gbuffer = g_buffers.d[pixel_idx];

	if (gbuffer.material_idx == -1) {
		return;
	}

	uint num_valid_samples = 0;

	Reservoir reservoir;
	init_reservoir(reservoir);

	Reservoir canonical_reservoir = reservoirs.d[offset(pc_ray.buffer_idx) + pixel_idx];

	float m_c = 1.0;

	uint num_spatial_samples = pc_ray.enable_spatial_reuse == 1 ? pc_ray.num_spatial_samples : 0;
	float curr_pdf = calc_target_pdf(canonical_reservoir.data.reservoir_contribution);
	uint valid_count = 0;
	for (uint i = 0; i < num_spatial_samples; i++) {
		ivec2 rand_offset = get_neighbor_offset(seed);
		const ivec2 coords = ivec2(gl_LaunchIDEXT.xy) + rand_offset;
		const uint neighbor_pixel_idx = coords.x * pc_ray.size_y + coords.y;
		if (any(lessThan(coords, ivec2(0))) || any(greaterThanEqual(coords, gl_LaunchSizeEXT.xy))) {
			continue;
		}
		num_valid_samples++;

		vec3 prefix_contribution;
		vec3 L_direct;
		vec3 rc_wo;
		vec3 partial_throughput;
		uint prefix_length;
		float jacobian;
		bool neighbor_visible = false;
		Reservoir neighbor_reservoir = reservoirs.d[offset(pc_ray.buffer_idx) + neighbor_pixel_idx];

		bool connected = connect_vertex(gbuffer, neighbor_reservoir.data, neighbor_reservoir.data.rc_g,
										primary_direction, neighbor_reservoir.data.init_seed, prefix_contribution,
										L_direct, partial_throughput, rc_wo, prefix_length, jacobian, neighbor_visible);
		float neighbor_pdf = calc_target_pdf(neighbor_reservoir.data.reservoir_contribution);
		float m_i = 0;
		float target_pdf = 0;
		if (connected) {
			neighbor_reservoir.data.F = prefix_contribution;
			neighbor_reservoir.data.reservoir_contribution =
				calc_reservoir_contribution(neighbor_reservoir.data, L_direct, rc_wo, partial_throughput);
			target_pdf = calc_target_pdf(neighbor_reservoir.data.reservoir_contribution);
			float m_i_num = neighbor_reservoir.M * neighbor_pdf;
			float m_i_denom = m_i_num + canonical_reservoir.M * target_pdf * jacobian / pc_ray.num_spatial_samples;
			m_i = m_i_denom == 0 ? 0 : m_i_num / m_i_denom;
		}

		float m_c_num = 0;
		bool center_visible = false;
		if (m_i > 0) {
			const vec2 neighbor_uv = vec2(coords + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);
			const vec2 neighbor_d = neighbor_uv * 2.0 - 1.0;
			vec3 neighbor_primary_direction = vec3(sample_camera(neighbor_d));
			vec3 prefix_contribution;
			vec3 L_direct;
			vec3 rc_wo;
			vec3 partial_throughput;
			uint prefix_length;
			float jacobian;
			GBuffer neighbor_gbuffer = g_buffers.d[neighbor_pixel_idx];
			bool connected =
				connect_vertex(neighbor_gbuffer, canonical_reservoir.data, canonical_reservoir.data.rc_g,
							   neighbor_primary_direction, canonical_reservoir.data.init_seed, prefix_contribution,
							   L_direct, partial_throughput, rc_wo, prefix_length, jacobian, center_visible);
			if (connected) {
				vec3 neighbor_contribution =
					calc_reservoir_contribution(canonical_reservoir.data, L_direct, rc_wo, partial_throughput);
				m_c_num = neighbor_reservoir.M * calc_target_pdf(neighbor_contribution) * jacobian;
			}
		}
		float m_c_denom = m_c_num + canonical_reservoir.M * curr_pdf / pc_ray.num_spatial_samples;
		float m_c_val = m_c_denom == 0.0 ? 0.0 : m_c_num / m_c_denom;
		if (m_c_val <= 0) {
			m_i = 0;
		}

		if (neighbor_visible && center_visible) {
			valid_count++;
		}

		ASSERT1(m_c_val > -1e-3 && m_c_val <= 1.001, "m_c_val <= 1.0 : %f\n", m_c_val);
		ASSERT1(m_i > -1e-3 && m_i <= 1.001, "m_i <= 1.0 : %f\n", m_i);

		m_c += 1.0 - m_c_val;
		combine_reservoir(seed, reservoir, neighbor_reservoir, target_pdf * jacobian * m_i);
	}
	bool canonical = combine_reservoir(seed, reservoir, canonical_reservoir, curr_pdf * m_c);
	float target_pdf = calc_target_pdf(reservoir.data.reservoir_contribution);
	reservoir.W = target_pdf == 0.0 ? 0.0 : reservoir.w_sum / (target_pdf * (1 + num_valid_samples));
	vec3 prefix_contribution = canonical_reservoir.data.F;
	if (reservoir.W > 0) {
		prefix_contribution = reservoir.data.F;
	}
	reservoir.data.F = prefix_contribution + calc_reservoir_integrand(reservoir);

	reservoirs.d[offset(1 - pc_ray.buffer_idx) + pixel_idx] = reservoir;
}