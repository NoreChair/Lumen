#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require

// TODO: Change prefix length when temporal reuse is added
#include "gris_commons.glsl"
GrisReservoir reservoirs = GrisReservoir(scene_desc.gris_reservoir_addr);
GrisGBuffer g_buffers = GrisGBuffer(scene_desc.gris_gbuffer_addr);
GrisDirectLighting direct_lighting_buffer = GrisDirectLighting(scene_desc.gris_direct_lighting_addr);
PrefixContributions prefix_contributions = PrefixContributions(scene_desc.prefix_contributions_addr);

ivec2 get_neighbor_offset(inout uvec4 seed) {
	const float randa = rand(seed) * 2 * PI;
	const float randr = sqrt(rand(seed)) * pc_ray.spatial_radius;
	return ivec2(floor(cos(randa) * randr), floor(sin(randa) * randr));
}

vec3 uniform_sample_light_with_visibility_override(inout uvec4 seed, const Material mat, vec3 pos, const bool side,
												   const vec3 n_s, const vec3 wo, bool visible_light) {
	vec3 res = vec3(0);
	// Sample light
	vec3 wi;
	float wi_len;
	float pdf_light_w;
	float pdf_light_a;
	LightRecord record;
	float cos_from_light;
	const vec3 Le =
		sample_light_Li(seed, pos, pc_ray.num_lights, pdf_light_w, wi, wi_len, pdf_light_a, cos_from_light, record);
	const vec3 p = offset_ray2(pos, n_s);
	float bsdf_pdf;
	float cos_x = dot(n_s, wi);
	vec3 f = eval_bsdf(n_s, wo, mat, 1, side, wi, bsdf_pdf, cos_x);
	if (visible_light && pdf_light_w > 0) {
		const float mis_weight = is_light_delta(record.flags) ? 1 : 1 / (1 + bsdf_pdf / pdf_light_w);
		res += mis_weight * f * abs(cos_x) * Le / pdf_light_w;
	}
	if (get_light_type(record.flags) == LIGHT_AREA) {
		// Sample BSDF
		f = sample_bsdf(n_s, wo, mat, 1, side, wi, bsdf_pdf, cos_x, seed);
		if (bsdf_pdf != 0) {
			traceRayEXT(tlas, flags, 0xFF, 0, 0, 0, p, tmin, wi, tmax, 0);
			if (payload.material_idx == record.material_idx && payload.triangle_idx == record.triangle_idx) {
				const float wi_len = length(payload.pos - pos);
				const float g = abs(dot(payload.n_s, -wi)) / (wi_len * wi_len);
				const float mis_weight = 1. / (1 + pdf_light_a / (g * bsdf_pdf));
				res += f * mis_weight * abs(cos_x) * Le / bsdf_pdf;
			}
		}
	}
	return res;
}

bool connect_vertex(in GBuffer gbuffer, in GrisData data, float g_prev, vec3 direction, uvec2 coords,
					out vec3 prefix_contribution, out vec3 L_direct, out vec3 partial_throughput, out vec3 rc_wo,
					out uint prefix_length, out float jacobian, out bool visibility) {
	if (data.rc_mat_id == -1) {
		return false;
	}

	bool rc_side;
	bool rc_nee_visible;
	uint reservoir_prefix_length;
	uint reservoir_postfix_length;
	unpack_path_flags(data.path_flags, rc_side, rc_nee_visible, reservoir_prefix_length, reservoir_postfix_length);

	Material hit_mat = load_material(gbuffer.material_idx, gbuffer.uv);
	vec3 pos = gbuffer.pos;
	vec3 prefix_throughput = vec3(1);

	prefix_contribution = vec3(0);
	L_direct = vec3(0);

	uint prefix_depth = 0;
	vec3 n_s = gbuffer.n_s;
	bool side = true;
	vec3 n_g = gbuffer.n_g;
	vec3 wo = -direction;
	bool specular = false;

	if (dot(n_g, wo) < 0.) n_g = -n_g;
	if (dot(n_g, n_s) < 0) {
		n_s = -n_s;
		side = false;
	}
	vec3 origin = offset_ray(gbuffer.pos, n_g);
	uvec4 reservoir_seed =
		init_rng(coords, gl_LaunchSizeEXT.xy, pc_ray.total_frame_num ^ pc_ray.random_num, data.init_seed);

	while (true) {
		if ((prefix_depth + reservoir_postfix_length) >= pc_ray.max_depth - 1) {
			return false;
		}

		vec3 wi = data.rc_pos - pos;
		float wi_len = length(wi);
		wi /= wi_len;

		if (prefix_depth > 0 && (hit_mat.bsdf_props & BSDF_SPECULAR) == 0) {
			const float light_pick_pdf = 1. / pc_ray.light_triangle_count;
			vec3 contrib = prefix_throughput *
						   uniform_sample_light(reservoir_seed, hit_mat, payload.pos, side, n_s, wo) / light_pick_pdf;
			prefix_contribution += contrib;
		}

		bool connectable = is_rough(hit_mat) && wi_len > pc_ray.min_vertex_distance_ratio * pc_ray.scene_extent;
		connectable = connectable && prefix_depth >= (reservoir_prefix_length - 1);
		bool connected = false;
		if (connectable) {
			vec3 p = offset_ray2(pos, n_s);
			any_hit_payload.hit = 1;
			traceRayEXT(tlas, gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT, 0xFF, 1, 0, 1, p,
						0, wi, wi_len - EPS, 1);
			connected = any_hit_payload.hit == 0;
			visibility = connected;
		}

		if (connected) {
			rc_wo = -wi;
			float rc_pdf;
			float cos_x = dot(n_s, wi);
			vec3 rc_f = eval_bsdf(n_s, wo, hit_mat, 1, side, wi, rc_pdf, cos_x);
			if (rc_pdf == 0) {
				return false;
			}
			// Compute the partial F
			partial_throughput = prefix_throughput * rc_f * abs(cos_x);
			// Compute the Jacobian
			float g_curr = abs(dot(data.rc_ns, rc_wo)) / (wi_len * wi_len);
			float j = g_prev == 0.0 ? 0.0 : g_curr / g_prev;
			jacobian = j;
			// Compute the direct lighting on the reconnection vertex
			const Material rc_mat = load_material(data.rc_mat_id, data.rc_uv);
			if (is_diffuse(rc_mat)) {
				L_direct = data.rc_Li;
			} else {
				const float light_pick_pdf = 1. / pc_ray.light_triangle_count;
				uvec4 reconnection_seed =
					init_rng(coords, gl_LaunchSizeEXT.xy, pc_ray.total_frame_num ^ pc_ray.random_num, data.rc_seed);
				L_direct += uniform_sample_light_with_visibility_override(reconnection_seed, rc_mat, data.rc_pos,
																		  rc_side, data.rc_ns, -wi, rc_nee_visible) /
							light_pick_pdf;
			}
			prefix_length = prefix_depth + 1;
			return true;
		}

		float pdf, cos_theta;
		const vec3 f =
			sample_bsdf(n_s, wo, hit_mat, 1 /*radiance=cam*/, side, direction, pdf, cos_theta, reservoir_seed);
		if (pdf == 0) {
			return false;
		}

		prefix_throughput *= f * abs(cos_theta) / pdf;
		specular = (hit_mat.bsdf_props & BSDF_SPECULAR) != 0;

		traceRayEXT(tlas, flags, 0xFF, 0, 0, 0, origin, tmin, direction, tmax, 0);
		const bool found_isect = payload.material_idx != -1;

		if (!found_isect) {
			return false;
		}
		hit_mat = load_material(payload.material_idx, payload.uv);

		if (specular) {
			prefix_contribution += prefix_throughput * hit_mat.emissive_factor;
		}

		wo = -direction;
		n_s = payload.n_s;
		side = true;
		n_g = payload.n_g;
		if (dot(payload.n_g, wo) < 0.) n_g = -n_g;
		if (dot(n_g, payload.n_s) < 0) {
			n_s = -n_s;
			side = false;
		}

		origin = offset_ray(payload.pos, n_g);
		pos = payload.pos;

		prefix_depth++;
	}

	return false;
}

void main() {
	const vec2 pixel = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 in_uv = pixel / vec2(gl_LaunchSizeEXT.xy);
	vec2 d = in_uv * 2.0 - 1.0;
	vec3 primary_direction = vec3(sample_camera(d));
	GBuffer gbuffer = g_buffers.d[pixel_idx];

	if (gbuffer.material_idx == -1) {
		return;
	}

	uint num_valid_samples = 0;

	Reservoir reservoir;
	init_reservoir(reservoir);

	Reservoir canonical_reservoir = reservoirs.d[pixel_idx];

	float m_c = 1.0;

	uint num_spatial_samples = pc_ray.enable_spatial_reuse == 1 ? pc_ray.num_spatial_samples : 0;
	float curr_pdf = calc_target_pdf(canonical_reservoir.data.reservoir_contribution);
	const vec3 canonical_prefix_contribution = prefix_contributions.d[pixel_idx];
	vec3 curr_prefix_contribution = canonical_prefix_contribution;
	for (uint i = 0; i < num_spatial_samples; i++) {
		ivec2 rand_offset = get_neighbor_offset(seed);
		const ivec2 coords = ivec2(gl_LaunchIDEXT.xy) + rand_offset;
		const uint neighbor_pixel_idx = coords.x * pc_ray.size_y + coords.y;
		if (any(lessThan(coords, ivec2(0))) || any(greaterThanEqual(coords, gl_LaunchSizeEXT.xy))) {
			continue;
		}
		num_valid_samples++;

		vec3 prefix_contribution;
		vec3 L_direct;
		vec3 rc_wo;
		vec3 partial_throughput;
		uint prefix_length;
		float jacobian;
		bool neighbor_visible = false;
		Reservoir neighbor_reservoir = reservoirs.d[neighbor_pixel_idx];

		bool connected = connect_vertex(gbuffer, neighbor_reservoir.data, neighbor_reservoir.data.rc_g,
										primary_direction, uvec2(coords), prefix_contribution, L_direct,
										partial_throughput, rc_wo, prefix_length, jacobian, neighbor_visible);
		float neighbor_pdf = calc_target_pdf(neighbor_reservoir.data.reservoir_contribution);
		float m_i = 0;
		float target_pdf = 0;
		if (connected) {
			neighbor_reservoir.data.reservoir_contribution =
				calc_reservoir_contribution(neighbor_reservoir.data, L_direct, rc_wo, partial_throughput);
			target_pdf = calc_target_pdf(neighbor_reservoir.data.reservoir_contribution);
			float m_i_num = neighbor_reservoir.M * neighbor_pdf;
			float m_i_denom = m_i_num + canonical_reservoir.M * target_pdf * jacobian / pc_ray.num_spatial_samples;
			m_i = m_i_denom == 0 ? 0 : m_i_num / m_i_denom;
		}

		float m_c_num = 0;
		bool center_visible = false;
		if (m_i > 0) {
			const vec2 neighbor_uv = vec2(coords + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);
			const vec2 neighbor_d = neighbor_uv * 2.0 - 1.0;
			vec3 neighbor_primary_direction = vec3(sample_camera(neighbor_d));
			vec3 prefix_contribution;
			vec3 L_direct;
			vec3 rc_wo;
			vec3 partial_throughput;
			uint prefix_length;
			float jacobian;
			GBuffer neighbor_gbuffer = g_buffers.d[neighbor_pixel_idx];
			bool connected =
				connect_vertex(neighbor_gbuffer, canonical_reservoir.data, canonical_reservoir.data.rc_g,
							   neighbor_primary_direction, uvec2(gl_LaunchIDEXT.xy), prefix_contribution, L_direct,
							   partial_throughput, rc_wo, prefix_length, jacobian, center_visible);
			if (connected) {
				vec3 neighbor_contribution =
					calc_reservoir_contribution(canonical_reservoir.data, L_direct, rc_wo, partial_throughput);
				m_c_num = neighbor_reservoir.M * calc_target_pdf(neighbor_contribution) * jacobian;
			}
		}
		float m_c_denom = m_c_num + canonical_reservoir.M * curr_pdf / pc_ray.num_spatial_samples;
		float m_c_val = m_c_denom == 0.0 ? 0.0 : m_c_num / m_c_denom;
		if (m_c_val <= 0) {
			m_i = 0;
		}
		ASSERT1(m_c_val > -1e-3 && m_c_val <= 1.001, "m_c_val <= 1.0 : %f\n", m_c_val);
		ASSERT1(m_i > -1e-3 && m_i <= 1.001, "m_i <= 1.0 : %f\n", m_i);

		m_c += 1.0 - m_c_val;
		bool accepted = combine_reservoir(seed, reservoir, neighbor_reservoir, target_pdf * jacobian * m_i);
		if(accepted) {
			curr_prefix_contribution = prefix_contribution;
		}
	}
	bool canonical = combine_reservoir(seed, reservoir, canonical_reservoir, curr_pdf * m_c);
	float target_pdf = calc_target_pdf(reservoir.data.reservoir_contribution);
	reservoir.W = target_pdf == 0.0 ? 0.0 : reservoir.w_sum / (target_pdf * (1 + num_valid_samples));
	if(canonical) {
		curr_prefix_contribution = canonical_prefix_contribution;
	}
	vec3 final_contribution = curr_prefix_contribution + calc_reservoir_integrand(reservoir);

	vec3 col = vec3(0);
	if (pc_ray.direct_lighting == 1) {
		col += direct_lighting_buffer.d[pixel_idx];
	}
	if (pc_ray.show_reconnection_radiance == 1) {
		col += reservoir.data.rc_postfix_L;
	} else {
		col += final_contribution;
	}

	ivec2 coords = ivec2(gl_LaunchIDEXT.xy);
	if (pc_ray.enable_accumulation == 0 || pc_ray.frame_num == 0) {
		imageStore(image, ivec2(coords), vec4(col, 1.f));
	} else {
		float w = 1. / float(pc_ray.frame_num + 1);
			vec3 old_col = imageLoad(image, ivec2(coords)).xyz;
			imageStore(image, ivec2(coords), vec4(mix(old_col, col, w), 1.f));
	}
}