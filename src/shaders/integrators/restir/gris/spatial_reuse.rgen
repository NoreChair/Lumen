#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require

// TODO: Change prefix length when temporal reuse is added
#include "gris_commons.glsl"
GrisReservoir reservoirs = GrisReservoir(scene_desc.gris_reservoir_addr);
GrisGBuffer g_buffers = GrisGBuffer(scene_desc.gris_gbuffer_addr);
GrisDirectLighting direct_lighting_buffer = GrisDirectLighting(scene_desc.gris_direct_lighting_addr);
PrefixContributions prefix_contributions = PrefixContributions(scene_desc.prefix_contributions_addr);

ivec2 get_neighbor_offset(inout uvec4 seed) {
	const float randa = rand(seed) * 2 * PI;
	const float randr = sqrt(rand(seed)) * pc_ray.spatial_radius;
	return ivec2(floor(cos(randa) * randr), floor(sin(randa) * randr));
}

void main() {
	GBuffer gbuffer = g_buffers.d[pixel_idx];
	if (gbuffer.material_idx == -1) {
		return;
	}

	Reservoir reservoir;
	init_reservoir(reservoir);

	Reservoir canonical_reservoir = reservoirs.d[pixel_idx];

	const vec3 canonical_prefix_contribution = prefix_contributions.d[pixel_idx];
	const vec3 canonical_reservoir_contribution = canonical_reservoir.data.reservoir_contribution;
	
	uint num_spatial_samples = pc_ray.enable_spatial_reuse == 1 ? pc_ray.num_spatial_samples : 0;
	vec3 curr_prefix_contribution = canonical_prefix_contribution;
	vec3 curr_reservoir_contribution = canonical_reservoir_contribution;
	float m_c = 1.0;
	const float canonical_in_canonical_pdf = calc_target_pdf(canonical_reservoir_contribution);
	uint num_valid_samples = 0;
	for (uint i = 0; i < num_spatial_samples; i++) {
		ivec2 rand_offset = get_neighbor_offset(seed);
		const ivec2 coords = ivec2(gl_LaunchIDEXT.xy) + rand_offset;
		const uint neighbor_pixel_idx = coords.x * pc_ray.size_y + coords.y;
		if (any(lessThan(coords, ivec2(0))) || any(greaterThanEqual(coords, gl_LaunchSizeEXT.xy))) {
			continue;
		}
		num_valid_samples++;

		const Reservoir neighbor_reservoir = reservoirs.d[neighbor_pixel_idx];
		vec3 prefix_contribution;
		vec3 reservoir_contribution;
		float jacobian;
		bool neighbor_in_canonical = retrace_paths(gbuffer, neighbor_reservoir.data, gl_LaunchIDEXT.xy, uvec2(coords),
												   prefix_contribution, jacobian, reservoir_contribution);

		if (!neighbor_in_canonical) {
			reservoir.M += neighbor_reservoir.M;
			m_c += 1.0;
			continue;
		}
		float neighbor_in_neighbor_pdf = calc_target_pdf(neighbor_reservoir.data.reservoir_contribution);
		float neighbor_in_canonical_pdf = calc_target_pdf(reservoir_contribution) * jacobian;
		const float m_i_num = neighbor_reservoir.M * neighbor_in_neighbor_pdf;
		const float m_i_denom =
			m_i_num + canonical_reservoir.M * neighbor_in_canonical_pdf / pc_ray.num_spatial_samples;
		const float m_i = m_i_denom == 0 ? 0 : m_i_num / m_i_denom;
		if (m_i <= 0) {
			reservoir.M += neighbor_reservoir.M;
			m_c += 1.0;
			continue;
		}
		GBuffer neighbor_gbuffer = g_buffers.d[neighbor_pixel_idx];
		float canonical_in_neighbor_pdf;
		bool canonical_in_neighbor = retrace_paths_and_evaluate(
			neighbor_gbuffer, canonical_reservoir.data, uvec2(coords), gl_LaunchIDEXT.xy, canonical_in_neighbor_pdf);
		if (!canonical_in_neighbor) {
			reservoir.M += neighbor_reservoir.M;
			m_c += 1.0;
			continue;
		}

		const float m_c_num = neighbor_reservoir.M * canonical_in_neighbor_pdf;

		const float m_c_denom =
			m_c_num + canonical_reservoir.M * canonical_in_canonical_pdf / pc_ray.num_spatial_samples;
		const float m_c_val = m_c_denom == 0.0 ? 0.0 : m_c_num / m_c_denom;
		if (m_c_val <= 0) {
			reservoir.M += neighbor_reservoir.M;
			m_c += 1.0;
			continue;
		}
		m_c += 1.0 - m_c_val;
		ASSERT1(m_c_val > -1e-3 && m_c_val <= 1.001, "m_c_val <= 1.0 : %f\n", m_c_val);
		ASSERT1(m_i > -1e-3 && m_i <= 1.001, "m_i <= 1.0 : %f\n", m_i);
		bool accepted = combine_reservoir(seed, reservoir, neighbor_reservoir, neighbor_in_canonical_pdf * m_i);
		if (accepted) {
			curr_prefix_contribution = prefix_contribution;
			curr_reservoir_contribution = reservoir_contribution;
		}
	}
	bool canonical = combine_reservoir(seed, reservoir, canonical_reservoir, canonical_in_canonical_pdf * m_c);
	if (canonical) {
		curr_prefix_contribution = canonical_prefix_contribution;
		curr_reservoir_contribution = canonical_reservoir_contribution;
	}
	const float target_pdf = calc_target_pdf(curr_reservoir_contribution);
	reservoir.W = target_pdf == 0.0 ? 0.0 : reservoir.w_sum / (target_pdf * (1 + num_valid_samples));

	vec3 final_contribution = curr_prefix_contribution;
	if (reservoir.W > 0) {
		final_contribution += curr_reservoir_contribution * reservoir.W;
	}

	vec3 col = vec3(0);
	if (pc_ray.direct_lighting == 1) {
		col += direct_lighting_buffer.d[pixel_idx];
	}
	if (pc_ray.show_reconnection_radiance == 1) {
		col += reservoir.data.rc_postfix_L;
	} else {
		col += final_contribution;
	}

	ivec2 coords = ivec2(gl_LaunchIDEXT.xy);
	if (pc_ray.enable_accumulation == 0 || pc_ray.frame_num == 0) {
		imageStore(image, ivec2(coords), vec4(col, 1.f));
	} else {
		float w = 1. / float(pc_ray.frame_num + 1);
		vec3 old_col = imageLoad(image, ivec2(coords)).xyz;
		imageStore(image, ivec2(coords), vec4(mix(old_col, col, w), 1.f));
	}
}