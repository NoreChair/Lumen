#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require

// TODO: Change prefix length when temporal reuse is added
#include "gris_commons.glsl"
GrisReservoir reservoirs = GrisReservoir(scene_desc.gris_reservoir_addr);
GrisGBuffer g_buffers = GrisGBuffer(scene_desc.gris_gbuffer_addr);
GrisDirectLighting direct_lighting_buffer = GrisDirectLighting(scene_desc.gris_direct_lighting_addr);
PrefixContributions prefix_contributions = PrefixContributions(scene_desc.prefix_contributions_addr);

ivec2 get_neighbor_offset(inout uvec4 seed) {
	const float randa = rand(seed) * 2 * PI;
	const float randr = sqrt(rand(seed)) * pc_ray.spatial_radius;
	return ivec2(floor(cos(randa) * randr), floor(sin(randa) * randr));
}

vec3 uniform_sample_light_with_visibility_override(inout uvec4 seed, const Material mat, vec3 pos, const bool side,
												   const vec3 n_s, const vec3 wo, bool visible_light) {
	vec3 res = vec3(0);
	// Sample light
	vec3 wi;
	float wi_len;
	float pdf_light_w;
	float pdf_light_a;
	LightRecord record;
	float cos_from_light;
	const vec3 Le =
		sample_light_Li(seed, pos, pc_ray.num_lights, pdf_light_w, wi, wi_len, pdf_light_a, cos_from_light, record);
	const vec3 p = offset_ray2(pos, n_s);
	float bsdf_pdf;
	float cos_x = dot(n_s, wi);
	vec3 f = eval_bsdf(n_s, wo, mat, 1, side, wi, bsdf_pdf, cos_x);
	if (visible_light && pdf_light_w > 0) {
		const float mis_weight = is_light_delta(record.flags) ? 1 : 1 / (1 + bsdf_pdf / pdf_light_w);
		res += mis_weight * f * abs(cos_x) * Le / pdf_light_w;
	}
	if (get_light_type(record.flags) == LIGHT_AREA) {
		// Sample BSDF
		f = sample_bsdf(n_s, wo, mat, 1, side, wi, bsdf_pdf, cos_x, seed);
		if (bsdf_pdf != 0) {
			traceRayEXT(tlas, flags, 0xFF, 0, 0, 0, p, tmin, wi, tmax, 0);
			if (payload.material_idx == record.material_idx && payload.triangle_idx == record.triangle_idx) {
				const float wi_len = length(payload.pos - pos);
				const float g = abs(dot(payload.n_s, -wi)) / (wi_len * wi_len);
				const float mis_weight = 1. / (1 + pdf_light_a / (g * bsdf_pdf));
				res += f * mis_weight * abs(cos_x) * Le / bsdf_pdf;
			}
		}
	}
	return res;
}

bool retrace_paths(in GBuffer gbuffer, in GrisData data, uvec2 source_coords, uvec2 target_coords,
				   out vec3 prefix_contribution, out float jacobian, out vec3 reservoir_contribution) {
	if (data.rc_mat_id == -1) {
		return false;
	}

	const vec2 uv = vec2(source_coords + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);
	const vec2 d = uv * 2.0 - 1.0;
	vec3 direction = vec3(sample_camera(d));

	bool rc_side;
	bool rc_nee_visible;
	uint reservoir_prefix_length;
	uint reservoir_postfix_length;
	unpack_path_flags(data.path_flags, rc_side, rc_nee_visible, reservoir_prefix_length, reservoir_postfix_length);

	Material hit_mat = load_material(gbuffer.material_idx, gbuffer.uv);
	vec3 prefix_throughput = vec3(1);

	prefix_contribution = vec3(0);

	uint prefix_depth = 0;
	bool specular = false;

	vec3 n_s = gbuffer.n_s;
	vec3 n_g = gbuffer.n_g;
	vec3 pos = gbuffer.pos;

	uvec4 reservoir_seed =
		init_rng(target_coords, gl_LaunchSizeEXT.xy, pc_ray.total_frame_num ^ pc_ray.random_num, data.init_seed);

	while (true) {
		if ((prefix_depth + reservoir_postfix_length) >= pc_ray.max_depth - 1) {
			return false;
		}

		vec3 wo = -direction;
		bool side = true;
		if (dot(n_g, wo) < 0.) n_g = -n_g;
		if (dot(n_g, n_s) < 0) {
			n_s = -n_s;
			side = false;
		}
		vec3 origin = offset_ray(pos, n_g);

		vec3 wi = data.rc_pos - pos;
		float wi_len = length(wi);
		wi /= wi_len;

		if (prefix_depth > 0 && (hit_mat.bsdf_props & BSDF_SPECULAR) == 0) {
			const float light_pick_pdf = 1. / pc_ray.light_triangle_count;
			vec3 contrib = prefix_throughput *
						   uniform_sample_light(reservoir_seed, hit_mat, payload.pos, side, n_s, wo) / light_pick_pdf;
			prefix_contribution += contrib;
		}

		bool connectable = is_rough(hit_mat) && wi_len > pc_ray.min_vertex_distance_ratio * pc_ray.scene_extent;
		connectable = connectable && prefix_depth >= (reservoir_prefix_length - 1);
		bool connected = false;
		if (connectable) {
			vec3 p = offset_ray2(pos, n_s);
			any_hit_payload.hit = 1;
			traceRayEXT(tlas, gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT, 0xFF, 1, 0, 1, p,
						0, wi, wi_len - EPS, 1);
			connected = any_hit_payload.hit == 0;
		}

		if (connected) {
			float rc_pdf;
			float cos_x = dot(n_s, wi);
			vec3 rc_f = eval_bsdf(n_s, wo, hit_mat, 1, side, wi, rc_pdf, cos_x);
			if (rc_pdf == 0) {
				return false;
			}
			// Compute the partial F
			vec3 partial_throughput = prefix_throughput * rc_f * abs(cos_x);
			// Compute the Jacobian
			float g_curr = abs(dot(data.rc_ns, wi)) / (wi_len * wi_len);
			float j = data.rc_g == 0.0 ? 0.0 : g_curr / data.rc_g;
			jacobian = j;
			// Compute the direct lighting on the reconnection vertex
			const Material rc_mat = load_material(data.rc_mat_id, data.rc_uv);

			vec3 L_direct;
			if (is_diffuse(rc_mat)) {
				L_direct = data.rc_Li;
			} else {
				const float light_pick_pdf = 1. / pc_ray.light_triangle_count;
				uvec4 reconnection_seed = init_rng(target_coords, gl_LaunchSizeEXT.xy,
												   pc_ray.total_frame_num ^ pc_ray.random_num, data.rc_seed);
				L_direct = uniform_sample_light_with_visibility_override(reconnection_seed, rc_mat, data.rc_pos,
																		 rc_side, data.rc_ns, -wi, rc_nee_visible) /
						   light_pick_pdf;
			}

			float rc_cos_x = dot(data.rc_ns, data.rc_wi);
			float bsdf_pdf;
			reservoir_contribution = L_direct;
			const vec3 f = eval_bsdf(data.rc_ns, wo, rc_mat, 1, rc_side, data.rc_wi, bsdf_pdf, rc_cos_x);
			if (bsdf_pdf > 0) {
				reservoir_contribution += f * abs(rc_cos_x) * data.rc_postfix_L / bsdf_pdf;
			}
			reservoir_contribution = partial_throughput * reservoir_contribution;
			return true;
		}

		float pdf, cos_theta;
		const vec3 f =
			sample_bsdf(n_s, wo, hit_mat, 1 /*radiance=cam*/, side, direction, pdf, cos_theta, reservoir_seed);
		if (pdf == 0) {
			return false;
		}

		prefix_throughput *= f * abs(cos_theta) / pdf;
		specular = (hit_mat.bsdf_props & BSDF_SPECULAR) != 0;

		traceRayEXT(tlas, flags, 0xFF, 0, 0, 0, origin, tmin, direction, tmax, 0);
		const bool found_isect = payload.material_idx != -1;

		if (!found_isect) {
			return false;
		}
		hit_mat = load_material(payload.material_idx, payload.uv);

		if (specular) {
			prefix_contribution += prefix_throughput * hit_mat.emissive_factor;
		}

		n_s = payload.n_s;
		n_g = payload.n_g;
		pos = payload.pos;

		prefix_depth++;
	}

	return false;
}

bool retrace_paths_and_evaluate(in GBuffer gbuffer, in GrisData data, uvec2 source_coords, uvec2 target_coords,
								out float target_pdf) {
	vec3 unused;
	vec3 reservoir_contribution;
	float jacobian;
	bool result = retrace_paths(gbuffer, data, source_coords, target_coords, unused, jacobian, reservoir_contribution);
	target_pdf = calc_target_pdf(reservoir_contribution) * jacobian;
	return result;
}

void main() {
	GBuffer gbuffer = g_buffers.d[pixel_idx];
	if (gbuffer.material_idx == -1) {
		return;
	}

	Reservoir reservoir;
	init_reservoir(reservoir);

	Reservoir canonical_reservoir = reservoirs.d[pixel_idx];

	const vec3 canonical_prefix_contribution = prefix_contributions.d[pixel_idx];
	const vec3 canonical_reservoir_contribution = canonical_reservoir.data.reservoir_contribution;
	
	uint num_spatial_samples = pc_ray.enable_spatial_reuse == 1 ? pc_ray.num_spatial_samples : 0;
	vec3 curr_prefix_contribution = canonical_prefix_contribution;
	vec3 curr_reservoir_contribution = canonical_reservoir_contribution;
	float m_c = 1.0;
	const float canonical_in_canonical_pdf = calc_target_pdf(canonical_reservoir_contribution);
	uint num_valid_samples = 0;
	for (uint i = 0; i < num_spatial_samples; i++) {
		ivec2 rand_offset = get_neighbor_offset(seed);
		const ivec2 coords = ivec2(gl_LaunchIDEXT.xy) + rand_offset;
		const uint neighbor_pixel_idx = coords.x * pc_ray.size_y + coords.y;
		if (any(lessThan(coords, ivec2(0))) || any(greaterThanEqual(coords, gl_LaunchSizeEXT.xy))) {
			continue;
		}
		num_valid_samples++;

		const Reservoir neighbor_reservoir = reservoirs.d[neighbor_pixel_idx];
		vec3 prefix_contribution;
		vec3 reservoir_contribution;
		float jacobian;
		bool neighbor_in_canonical = retrace_paths(gbuffer, neighbor_reservoir.data, gl_LaunchIDEXT.xy, uvec2(coords),
												   prefix_contribution, jacobian, reservoir_contribution);

		if (!neighbor_in_canonical) {
			reservoir.M += neighbor_reservoir.M;
			m_c += 1.0;
			continue;
		}
		float neighbor_in_neighbor_pdf = calc_target_pdf(neighbor_reservoir.data.reservoir_contribution);
		float neighbor_in_canonical_pdf = calc_target_pdf(reservoir_contribution) * jacobian;
		const float m_i_num = neighbor_reservoir.M * neighbor_in_neighbor_pdf;
		const float m_i_denom =
			m_i_num + canonical_reservoir.M * neighbor_in_canonical_pdf / pc_ray.num_spatial_samples;
		const float m_i = m_i_denom == 0 ? 0 : m_i_num / m_i_denom;
		if (m_i <= 0) {
			reservoir.M += neighbor_reservoir.M;
			m_c += 1.0;
			continue;
		}
		GBuffer neighbor_gbuffer = g_buffers.d[neighbor_pixel_idx];
		float canonical_in_neighbor_pdf;
		bool canonical_in_neighbor = retrace_paths_and_evaluate(
			neighbor_gbuffer, canonical_reservoir.data, uvec2(coords), gl_LaunchIDEXT.xy, canonical_in_neighbor_pdf);
		if (!canonical_in_neighbor) {
			reservoir.M += neighbor_reservoir.M;
			m_c += 1.0;
			continue;
		}

		const float m_c_num = neighbor_reservoir.M * canonical_in_neighbor_pdf;

		const float m_c_denom =
			m_c_num + canonical_reservoir.M * canonical_in_canonical_pdf / pc_ray.num_spatial_samples;
		const float m_c_val = m_c_denom == 0.0 ? 0.0 : m_c_num / m_c_denom;
		if (m_c_val <= 0) {
			reservoir.M += neighbor_reservoir.M;
			m_c += 1.0;
			continue;
		}
		m_c += 1.0 - m_c_val;
		ASSERT1(m_c_val > -1e-3 && m_c_val <= 1.001, "m_c_val <= 1.0 : %f\n", m_c_val);
		ASSERT1(m_i > -1e-3 && m_i <= 1.001, "m_i <= 1.0 : %f\n", m_i);
		bool accepted = combine_reservoir(seed, reservoir, neighbor_reservoir, neighbor_in_canonical_pdf * m_i);
		if (accepted) {
			curr_prefix_contribution = prefix_contribution;
			curr_reservoir_contribution = reservoir_contribution;
		}
	}
	bool canonical = combine_reservoir(seed, reservoir, canonical_reservoir, canonical_in_canonical_pdf * m_c);
	if (canonical) {
		curr_prefix_contribution = canonical_prefix_contribution;
		curr_reservoir_contribution = canonical_reservoir_contribution;
	}
	const float target_pdf = calc_target_pdf(curr_reservoir_contribution);
	reservoir.W = target_pdf == 0.0 ? 0.0 : reservoir.w_sum / (target_pdf * (1 + num_valid_samples));

	vec3 final_contribution = curr_prefix_contribution;
	if (reservoir.W > 0) {
		final_contribution += curr_reservoir_contribution * reservoir.W;
	}

	vec3 col = vec3(0);
	if (pc_ray.direct_lighting == 1) {
		col += direct_lighting_buffer.d[pixel_idx];
	}
	if (pc_ray.show_reconnection_radiance == 1) {
		col += reservoir.data.rc_postfix_L;
	} else {
		col += final_contribution;
	}

	ivec2 coords = ivec2(gl_LaunchIDEXT.xy);
	if (pc_ray.enable_accumulation == 0 || pc_ray.frame_num == 0) {
		imageStore(image, ivec2(coords), vec4(col, 1.f));
	} else {
		float w = 1. / float(pc_ray.frame_num + 1);
		vec3 old_col = imageLoad(image, ivec2(coords)).xyz;
		imageStore(image, ivec2(coords), vec4(mix(old_col, col, w), 1.f));
	}
}